import numpy as np
import matplotlib.pyplot as plt
import tensorflow.keras
import sys
import os
import logging
import galsim
import random
import cmath as cm
import math
from tensorflow.keras import backend as K
from tensorflow.keras import metrics
from tensorflow.keras.layers import Input, Dense, Lambda, Layer, Add, Multiply, BatchNormalization, Reshape, Flatten, Conv2D,  PReLU,Conv2DTranspose
from tensorflow.keras.models import Model, Sequential
from scipy.stats import norm
import tensorflow as tf

from . import utils, plot

######### VAE #########

def VAE_processing(vae, generator,bands,r_band,im_size, N, batch_size):
    """
    Returns 

    Paramters:
    ---------
    vae: vae to test
    generator: generator of input images (input of network and target) and parameters for processing results (SNR, scale radius)
    bands: band-pass filters used for this VAE
    r_band: R band-pass filter number in the bands list.
    im_size= size of the stamp for the creation of images
    N: number of batch to test
    batch_size: size of the batches generated by generator
    """

    # see LSST Science Book
    pix_scale = 0.2 #arcseconds
    PSF_fwhm = 0.1
    PSF_beta = 2.5

    psf = galsim.Moffat(fwhm=PSF_fwhm, beta=PSF_beta)
    psf_image = psf.drawImage(nx=im_size, ny=im_size, scale=pix_scale)

    ellipticities = []
    redshift_R=[]
    e=[]
    SNR = []
    scale_radius = []

    flux_in = np.empty([N,N,],dtype='float32')
    flux_out= np.empty([N,N,], dtype='float32')

    for j in range(N):
        input_vae = generator.__getitem__(2)
        output_vae = vae.predict(input_vae[0], batch_size = batch_size)
        #input_noiseless = input_vae[1]
        input_noiseless = utils.denorm(input_vae[1], bands, channel_last = True)
        output_vae = utils.denorm (output_vae, bands, channel_last = True)

        for i in range (len(input_vae[0])):
            try: 
                gal_image = galsim.Image(input_noiseless[i][:,:,r_band])
                gal_image.scale = pix_scale

                gal_image_out = galsim.Image(output_vae[i][:,:,r_band])
                gal_image_out.scale = pix_scale

                # Measurements of shapes
                res = galsim.hsm.EstimateShear(gal_image, psf_image)
                e_in = [res.corrected_e1, res.corrected_e2]
                e_beta_in = [res.observed_shape.e, res.observed_shape.beta.rad]

                res_out = galsim.hsm.EstimateShear(gal_image_out, psf_image)
                e_out = [res_out.corrected_e1, res_out.corrected_e2]
                e_beta_out = [res_out.observed_shape.e, res_out.observed_shape.beta.rad]

                ellipticities.append([e_in, e_out])
                e.append([e_beta_in, e_beta_out])

                # Measurement of fluxes
                mask = plot.createCircularMask(im_size,im_size,None,5)
                masked_img_in_simple = input_noiseless[i][:,:,r_band].copy()
                masked_img_in_simple[~mask] = 0  

                masked_img_out_simple = output_vae[i][:,:,r_band].copy()
                masked_img_out_simple[~mask] = 0

                # Calculate the luminosity by substracting the noise
                flux_in[j,i] = np.sum(masked_img_in_simple)
                flux_out[j,i] = np.sum(masked_img_out_simple)
                
                # Save scale radius and SNR
                scale_radius.append(input_vae[2][i])
                SNR.append(input_vae[3][i])
        
            except :
                print('erreur')
                pass
            continue

    ellipticities = np.array(ellipticities)
    e_beta = np.array(e)
    scale_radius = np.array(scale_radius)
    SNR = np.array(SNR)

    flux_in = np.concatenate(flux_in)
    flux_out = np.concatenate(flux_out)

    return ellipticities, e_beta, flux_in, flux_out, scale_radius, SNR 



######### Deblender #########

def deblender_processing(deblender, generator,bands,r_band,im_size, N, batch_size):
    """
    Returns 

    Paramters:
    ---------
    deblender: deblender to test
    generator: generator of input images (input of network and target) and parameters for processing results (SNR, scale radius)
    bands: band-pass filters used for this VAE
    r_band: R band-pass filter number in the bands list.
    im_size= size of the stamp for the creation of images
    N: number of batch to test
    batch_size: size of the batches generated by generator
    """
    # see LSST Science Book
    pix_scale = 0.2 #arcseconds
    PSF_fwhm = 0.1
    PSF_beta = 2.5

    psf = galsim.Moffat(fwhm=PSF_fwhm, beta=PSF_beta)
    psf_image = psf.drawImage(nx=im_size, ny=im_size, scale=pix_scale)

    ellipticities = []
    e = []
    magnitudes = []
    deltas_r = []
    deltas_m = []
    max_blendedness = []

    flux_in = np.empty([N,N,],dtype='float32')
    flux_out= np.empty([N,N,], dtype='float32')
    for j in range(N):
        input_vae = generator.__getitem__(2)
        output_vae = deblender.predict(input_vae[0], batch_size = batch_size)
        output_vae = utils.denorm(output_vae, bands, channel_last = True)
        input_noiseless = utils.denorm(input_vae[1], bands, channel_last = True)

        for i in range (len(input_vae[0])):
                try: 
                    gal_image = galsim.Image(input_noiseless[i][:,:,r_band])
                    gal_image.scale = pix_scale

                    res = galsim.hsm.EstimateShear(gal_image, psf_image)
                    e_in = [res.corrected_e1, res.corrected_e2]
                    e_beta_in = [res.observed_shape.e, res.observed_shape.beta.rad]

                    gal_image_out = galsim.Image(output_vae[i][:,:,r_band])
                    gal_image_out.scale = pix_scale

                    res = galsim.hsm.EstimateShear(gal_image_out, psf_image)
                    e_out = [res.corrected_e1, res.corrected_e2]
                    e_beta_out = [res.observed_shape.e, res.observed_shape.beta.rad]

                    ellipticities.append([e_in, e_out])
                    e.append([e_beta_in, e_beta_out])

                    magnitudes.append(input_vae[2])
                        
                    # Measurement of fluxes
                    mask = plot.createCircularMask(im_size,im_size,None,5)
                    masked_img_in_simple = input_noiseless[i][:,:,r_band].copy()
                    masked_img_in_simple[~mask] = 0  

                    masked_img_out_simple = output_vae[i][:,:,r_band].copy()
                    masked_img_out_simple[~mask] = 0

                    # Calculate the luminosity by substracting the noise
                    flux_in[j,i] = np.sum(masked_img_in_simple)
                    flux_out[j,i] = np.sum(masked_img_out_simple)

                except :
                    print('error for galaxy '+str(j*100+i))
                    pass
                continue
                
        delta_r = input_vae[4] 
        delta_mag = input_vae[5]
        max_blend = input_vae[6]
        deltas_r.append(delta_r)
        deltas_m.append(delta_mag)
        max_blendedness.append(max_blend)
        
    ellipticities = np.array(ellipticities)
    e_beta = np.array(e)
    magnitudes = np.array(magnitudes)
    delta_r_arr = np.array(deltas_r)
    delta_mag_arr = np.array(deltas_m)
    max_blendedness_arr = np.array(max_blendedness)

    flux_in = np.concatenate(flux_in)
    flux_out = np.concatenate(flux_out)

    return ellipticities,e_beta, flux_in, flux_out, magnitudes, delta_r_arr, delta_mag_arr, max_blendedness_arr